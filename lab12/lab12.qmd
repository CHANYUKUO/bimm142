---
title: "Lab12"
author: "Chan-yu Kuo"
format: pdf
editor: visual
---

```{r}
library(BiocManager)
library(DESeq2)
```

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

```{r}
head(counts)
head(metadata)
```

How many genes are in this dataset?

```{r}
nrow(counts)
```

How many 'control' cell lines do we have?

4

```{r}
#metadata[,"dex"]=="control"
control <- metadata[metadata[,"dex"]=="control",]
head(control)
control.counts <- counts[ ,control$id]
#control.counts
control.mean <- rowSums( control.counts )/4 
head(control.mean)
```

-   **Q4.** Follow the same procedure for the `treated` samples (i.e.Â calculate the mean per gene across drug treated samples and assign to a labeled vector called `treated.mean`)

```{r}
treated <- metadata[metadata[,"dex"]=="treated",]
head(treated)
treated.counts <- counts[ ,treated$id]
#control.counts
treated.mean <- rowSums( treated.counts )/4 
head(treated.mean)
```

-   **Q3.** How would you make the above code in either approach more robust?

-   add more sample, we reduce the effect of the outlier, getting more robust result

```{r}
library(dplyr)
control <- metadata %>% filter(dex=="control")
control.counts <- counts %>% select(control$id) 
control.mean <- rowSums(control.counts)/4
head(control.mean)
```

```{r}
meancounts <- data.frame(control.mean, treated.mean)
plot(meancounts[,1],meancounts[,2], xlab="Control", ylab="Treated",log="xy")
```

**Q5 (b).**You could also use the **ggplot2** package to make this figure producing the plot below. What **geom\_?()** function would you use for this plot?

geom_points

**Q6.** Try plotting both axes on a log scale. What is the argument to **plot()** that allows you to do this?

log=="xy"

```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```

```{r}
head(meancounts[,1:2]==0)
## this return a group of index that is equal to 0
to.keep <- rowSums(meancounts[,1:2]==0)==0
mycounts <- meancounts[to.keep,]
head(mycounts)
#zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)
#to.rm <- unique(zero.vals[,1])

#mycounts <- meancounts[-to.rm,]
#head(mycounts)
```

-   **Q7.** What is the purpose of the `arr.ind` argument in the **which()** function call above? Why would we then take the first column of the output and need to call the **unique()** function?

arr.ind is the array indices if the input is an array.

here is the Upregulated log2fc with cutoff of 2

314 upregulated

```{r}
#mycounts[mycounts$log2fc>=2,]
sum(mycounts$log2fc>=2)
```

Here is the downregulated ;

485 downregulated

```{r}
#mycounts[mycounts$log2fc<=-2,]
sum(mycounts$log2fc<=-2)
```

Q8 and Q9

```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
sum(up.ind)
sum(down.ind )
```

Q10

No, fold can be large without being statistically significant, meaning the fold change result might be due to randomness.

we should filter out any result with high p_value, when using fold change to inspect result

```{r}
library(DESeq2)
citation("DESeq2")
```

```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```

```{r}
dds <- DESeq(dds)
```

```{r}
res<- results(dds)
res
```

volcano plots

flip the y-axis so the value we care(low p-value)

```{r}

plot(res$log2FoldChange,-log(res$padj))
```

```{r}
mycols<-rep("grey",nrow(res))
mycols[abs(res$log2FoldChange)>=2]<-"blue"
mycols[abs(res$padj)>=0.05]<-"gray"
plot(res$log2FoldChange,-log(res$padj),col=mycols)
```

Annotation

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     )

```

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="ENTREZID",          # The new format we want to add
                     )
```

```{r}
res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="UNIPROT",          # The new format we want to add
                     )
```

```{r}
res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="GENENAME",          # The new format we want to add
                     )
```

```{r}
library(pathview)
library(gage)
library(gageData)

data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)

```

The main **gage()** function requires a named vector of fold changes, where the names of the values are the Entrez gene IDs.

```{r}
c(ian=5,tim=1)
```

```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
## 7105 is the entrez name, 
```

```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

```{r}
attributes(keggres)
```

```{r}
# Look at the first three down (less) pathways
head(keggres$less, 3)
```

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05332")
```

![here is a pathway view for hsa05332 from our deseq2 analysis](hsa05332.pathview.png)

```{r}

```
